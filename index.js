// Generated by CoffeeScript 1.8.0
(function() {
  var Grid, GridStore, Promise, client, concat, path, server, stream, util, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  path = require('path');

  util = require('util');

  stream = require('stream');

  _ = require('lodash');

  concat = require('concat-stream');

  Grid = require('gridfs-stream');

  Promise = require('bluebird');

  server = require('mongodb');

  client = server.MongoClient;

  GridStore = server.GridStore;

  module.exports = function(opts) {

    /*
    		opts:
    			uri:	'mongodb://user:password@localhost:27017/file'
    			
    			or 
    			
    			scheme: "mongodb"
    			hosts: [
    				{host: 'host1', port: port1}
    				{host: 'host2', port: port2}
    				...
    			]
    			username: "username"
    			password: "password"
    			database: "db"
    			options:
    				authSource: "admin"
     */
    var mongodbUri, self;
    self = {
      opts: opts
    };
    mongodbUri = require('mongodb-uri');
    _.defaults(self.opts, {
      scheme: 'mongodb',
      bucket: GridStore.DEFAULT_ROOT_COLLECTION,
      port: 27017
    });
    self.conn = client.connect(self.opts.uri || mongodbUri.format(self.opts), {
      promiseLibrary: Promise
    }).then(function(db) {
      self.db = db;
      return self.gfs = Grid(self.db, server);
    });
    return {
      ls: function(dirname) {
        return self.conn.then(function() {
          var index;
          index = {
            filename: 1,
            uploadDate: -1
          };
          return self.gfs.collection(self.opts.bucket).ensureIndex(index, function(err, indexName) {
            if (err) {
              return Promise.reject(err);
            }
            return self.gfs.collection(self.opts.bucket).distinct('filename', {
              'metadata.dirname': dirname
            }, function(err, files) {
              if (err) {
                return Promise.reject(err);
              }
              return files;
            });
          });
        });
      },
      read: function(fd) {
        return this.readLastVersion(fd, cb);
      },
      readLastVersion: function(fd) {
        return this.readVersion(fd, -1, cb);
      },
      readVersion: function(fd, version) {
        return self.conn.then(function() {
          return self.gfs.collection(self.opts.bucket).find({
            filename: fd
          }).limit(-1).skip(version < 0 ? Math.abs(version) - 1 : version).sort({
            uploadDate: version < 0 ? -1 : 1
          }).next(function(err, file) {
            var gridStore;
            if (err) {
              return Promise.reject(err);
            }
            if (!file) {
              err = new Error('ENOENT');
              _.extend(err, {
                name: 'Error (ENOENT)',
                code: 'ENOENT',
                status: 404,
                message: "No file exists in this mongo gridfs bucket with that file descriptor (" + fd + ")"
              });
              return Promise.reject(err);
            }
            gridStore = new GridStore(self.db, file._id, 'r', {
              root: self.opts.bucket
            });
            return gridStore.open(function(err, gridStore) {
              if (err) {
                return reject(err);
              }
              stream = gridStore.stream();
              stream.pipe(concat(Promise.resolve));
              return stream.on('error', Promise.reject);
            });
          });
        });
      },
      rm: function(fd) {
        return self.conn.then(function() {
          return self.gfs.exist({
            filename: fd,
            root: self.opts.bucket
          }, function(err, found) {
            if (err) {
              return Promise.reject(err);
            }
            if (!found) {
              return Promise.reject("" + fd + " not found");
            }
            return self.gfs.remove({
              filename: fd,
              root: self.opts.bucket
            }, function(err) {
              if (err) {
                return Promise.reject(err);
              }
            });
          });
        });
      },
      receive: function(opts) {
        var Receiver;
        Receiver = (function(_super) {
          __extends(Receiver, _super);

          function Receiver(opts) {
            if (opts == null) {
              opts = {};
            }
            _.defaults(opts, {
              objectMode: true
            });
            Receiver.__super__.constructor.call(this, opts);
          }

          Receiver.prototype._write = function(__newFile, encoding, done) {
            var fd;
            fd = __newFile.fd;
            return self.conn.then((function(_this) {
              return function() {
                var metadata;
                metadata = _.extend(__newFile.metadata || {}, {
                  fd: fd,
                  dirname: __newFile.dirname || path.dirname(fd)
                });
                _this.outs = self.gfs.createWriteStream({
                  filename: fd,
                  root: self.opts.bucket,
                  metadata: metadata
                });
                _this.outs.once('open', function() {
                  return __newFile.extra = _.assign({
                    fileId: this.id
                  }, metadata);
                });
                _this.outs.once('close', function(file) {
                  return done(null, file);
                });
                __newFile.once('error', function(err) {
                  var _ref;
                  if ((_ref = _this.outs) != null) {
                    _ref.end();
                  }
                  return Promise.reject(err);
                });
                _this.outs.once('error', Promise.reject);
                return __newFile.pipe(_this.outs);
              };
            })(this))["catch"]((function(_this) {
              return function(err) {
                _this.end();
                return done(err);
              };
            })(this));
          };

          return Receiver;

        })(stream.Writable);
        return new Receiver;
      }
    };
  };

}).call(this);
