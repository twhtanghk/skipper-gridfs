// Generated by CoffeeScript 1.8.0
(function() {
  var Grid, GridStore, Promise, client, concat, path, server, stream, util, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  path = require('path');

  util = require('util');

  stream = require('stream');

  _ = require('lodash');

  concat = require('concat-stream');

  Grid = require('gridfs-stream');

  Promise = require('bluebird');

  server = require('mongodb');

  client = server.MongoClient;

  GridStore = server.GridStore;

  module.exports = function(opts) {

    /*
    		opts:
    			uri:	'mongodb://user:password@localhost:27017/file'
    			
    			or 
    			
    			scheme: "mongodb"
    			hosts: [
    				{host: 'host1', port: port1}
    				{host: 'host2', port: port2}
    				...
    			]
    			username: "username"
    			password: "password"
    			database: "db"
    			options:
    				authSource: "admin"
     */
    var mongodbUri, self;
    self = {
      opts: opts
    };
    mongodbUri = require('mongodb-uri');
    _.defaults(self.opts, {
      scheme: 'mongodb',
      bucket: GridStore.DEFAULT_ROOT_COLLECTION,
      port: 27017
    });
    self.conn = new Promise(function(fulfill, reject) {
      return client.connect(self.opts.uri || mongodbUri.format(self.opts)).then(function(db) {
        self.db = db;
        self.gfs = Grid(self.db, server);
        return fulfill();
      })["catch"](reject);
    });
    return {
      ls: function(dirname, cb) {
        var ret;
        ret = new Promise(function(fulfill, reject) {
          return self.conn.then(function() {
            var index;
            index = {
              filename: 1,
              uploadDate: -1
            };
            return self.gfs.collection(self.opts.bucket).ensureIndex(index, function(err, indexName) {
              if (err) {
                return reject(err);
              }
              return self.gfs.collection(self.opts.bucket).distinct('filename', {
                'metadata.dirname': dirname
              }, function(err, files) {
                if (err) {
                  return reject(err);
                }
                return fulfill(files);
              });
            });
          })["catch"](reject);
        });
        if (cb) {
          ret.nodeify(cb);
          return this;
        }
        return ret;
      },
      read: function(fd, cb) {
        return this.readLastVersion(fd, cb);
      },
      readLastVersion: function(fd, cb) {
        return this.readVersion(fd, -1, cb);
      },
      readVersion: function(fd, version, cb) {
        var ret;
        ret = new Promise(function(fulfill, reject) {
          return self.conn.then(function() {
            return self.gfs.collection(self.opts.bucket).find({
              filename: fd
            }).limit(-1).skip(version < 0 ? Math.abs(version) - 1 : version).sort({
              uploadDate: version < 0 ? -1 : 1
            }).next(function(err, file) {
              var gridStore;
              if (err) {
                console.log(err);
                return reject(err);
              }
              if (!file) {
                err = new Error('ENOENT');
                _.extend(err, {
                  name: 'Error (ENOENT)',
                  code: 'ENOENT',
                  status: 404,
                  message: "No file exists in this mongo gridfs bucket with that file descriptor (" + fd + ")"
                });
                return reject(err);
              }
              gridStore = new GridStore(self.db, file._id, 'r', {
                root: self.opts.bucket
              });
              return gridStore.open(function(err, gridStore) {
                if (err) {
                  return reject(err);
                }
                stream = gridStore.stream();
                stream.pipe(concat(fulfill));
                return stream.on('error', reject);
              });
            });
          })["catch"](reject);
        });
        if (cb) {
          ret.nodeify(cb);
          return this;
        }
        return ret;
      },
      rm: function(fd, cb) {
        var ret;
        ret = new Promise(function(fulfill, reject) {
          return self.conn.then(function() {
            return self.gfs.exist({
              filename: fd,
              root: self.opts.bucket
            }, function(err, found) {
              if (err) {
                return reject(err);
              }
              if (!found) {
                return reject("" + fd + " not found");
              }
              return self.gfs.remove({
                filename: fd,
                root: self.opts.bucket
              }, function(err) {
                if (err) {
                  return reject(err);
                }
                return fulfill();
              });
            });
          })["catch"](reject);
        });
        if (cb) {
          ret.nodeify(cb);
          return this;
        }
        return ret;
      },
      receive: function(opts) {
        var Receiver;
        Receiver = (function(_super) {
          __extends(Receiver, _super);

          function Receiver(opts) {
            if (opts == null) {
              opts = {};
            }
            _.defaults(opts, {
              objectMode: true
            });
            Receiver.__super__.constructor.call(this, opts);
          }

          Receiver.prototype._write = function(__newFile, encoding, done) {
            var fd;
            fd = __newFile.fd;
            return self.conn.then((function(_this) {
              return function() {
                _this.outs = self.gfs.createWriteStream({
                  filename: fd,
                  root: self.opts.bucket,
                  metadata: {
                    fd: fd,
                    dirname: __newFile.dirname || path.dirname(fd)
                  }
                });
                _this.outs.once('open', function() {
                  return __newFile.extra = _.assign({
                    fileId: this.id
                  }, this.options.metadata);
                });
                _this.outs.once('close', function(file) {
                  return done(null, file);
                });
                __newFile.once('error', function(err) {
                  _this.end();
                  return _this.outs.end();
                });
                _this.outs.once('error', function(err) {
                  _this.end();
                  return done(err);
                });
                return __newFile.pipe(_this.outs);
              };
            })(this))["catch"](function(err) {
              console.log('mongo connection not available');
              return done(err);
            });
          };

          return Receiver;

        })(stream.Writable);
        return new Receiver;
      }
    };
  };

}).call(this);
